## Задание 2. Реализация нейронной сети для детекции объектов CenterNet.

### Описание
В этом задании вам необходимо реализовать на torch упрощенную версию сети CenterNet, статья [Objects as Points](https://arxiv.org/pdf/1904.07850.pdf).
Аналогично первому заданию, имеется пакет-заготовка для реализации сети. Ваша задача - разобраться в статье и реализовать те фрагменты, где в коде встречается
 `raise NotImplementedError` (а также `pass #NotImplemented`).

Замечания:
- изучение кода [оригинальной](https://github.com/xingyizhou/CenterNet) CenterNet приветствуется.
- не перепутайте с другой статьей [CenterNet: Keypoint Triplets for Object Detection](https://arxiv.org/abs/1904.08189): она сложнее!

### Оценка
Оценка ставится инструкторами вручную, с проверкой реализации компонентов и результатов тренировки.
В срок [10.10 – 31.10], `максимум баллов за задание` = 20. Начиная с 31.10, `максимум баллов за задание` = 10. Начиная с 15.12, баллы не ставятся.

### Список компонентов, которые надо реализовать
- a4_course_cvdl_t2.backbone.UpscaleTwiceLayer (2 балла)
- a4_course_cvdl_t2.backbone.HeadlessResnet34 (2 балла)
- a4_course_cvdl_t2.head.CenterNetHead (2 балла)
- a4_course_cvdl_t2.loss.CenterNetLoss (2 балла)
- a4_course_cvdl_t2.convert.ObjectsToPoints (3 балла)
- a4_course_cvdl_t2.convert.PointsToObjects (4 балла)
- a4_course_cvdl_t2.network.PointsNonMaxSuppression (3 балла)

Корректность компонентов оценивается по тестам и "на глаз": если компонент не проходит почему-то тест, но по смыслу верен, он будет засчитан
Все компоненты - 18 баллов. Еще 2 балла даются за "успешную" тренировку на TinyCoco( см. ниже ).

### Баллы за тренировку на TinyCoco
Для удобства отладки приложен `task2/checks_notebook.ipynb`, в котором сначала вызываются компоненты по-отдельности, а затем выполняется тренировка на датасете TinyCoco (игрушечная)
Датасет TinyCoco приложен в task2/data, для тренировки на нем достаточно CPU.

Тренировку можно делать с pretrained бэкбоном.

Тренировка считается успешной, если лосс в логах тренировки (выводятся в checks_notebook.ipynb) стабильно понижается.

### Дополнительные баллы за тренировку на CocoText
При тренировке на TinyCoco (~10 изображений) чего-то даже отдаленно работающего не получится в любом случае - слишком мало данных. Чтобы проверить, работоспособен ли написанный вами детектор, его надо обучить на полноразмерном датасете (~10K изображений).

В ноутбуке `train_cocotext.ipynb` приведена тренировка детектора на [CocoText](https://bgshih.github.io/cocotext/) - датасете с изображениями из COCO, на которых размечен весь текст.

Вам необходимо скачать изображения [COCO](https://cocodataset.org) версии 2014 года и разметку cocotext.v2.json с сайта CocoText, прогнать обучение в ноутбуке на своей реализации CenterNet и удостовериться, что ваше детектор после обучения выдаёт что-то похожее на детекции текста.

За успешную тренировку на CocoText дополнительно начисляется 3 балла. У этого пункта дедлайн - конец семестра, т.е. получить доп. баллы за успешную тренировку работающего детектора можно и после 31.10.


=============
Ревью
=============
Всё ок, полный балл.
Заметки:
- NMS имеет небольшой дефект
```python
    def forward(self, points):
        classes = points.shape[1] - 4
        cleared_points = torch.max(points[:, 0:classes], dim = 1)[0]
        # --- выбрали поканальный максимум в каждой локации
        maxes = nn.MaxPool2d(kernel_size = 3, stride = 1, padding = 1)(cleared_points)
        equality = ((maxes == cleared_points).repeat_interleave(classes + 4, 0)).reshape(points.shape)
        # оставили только точки, которые имеют максимум в kernel-окрестности
        return points * equality
```
Пусть предсказывается 2 класса А и B, и в двух соседних локациях:
P[0, c_a, 0, 0] = 0.9
P[0, c_b, 0, 0] = 0.1
P[0, c_a, 0, 1] = 0.2
P[0, c_b, 0, 1] = 0.8
Тогда после max останутся значения [0.9, 0.8], а после keep останется [0.9, 0.], т.е пик класса А задавит в соседней локации пик класса B.
CenterNet в любом случае плохо будет работать в такой ситуации, но авторы используют nms, где пики каждого класса давят только соседнии локации своего же класса.
